"use strict";

exports.__esModule = true;

var _events = require("events");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-underscore-dangle */


var NOOP = function NOOP() {};

function removePortFromAddress(address) {
  return address ? address.replace(/:[0-9]*$/, "") : address;
}

/**
 * Create a fake connection object
 *
 * @param {Object} context Azure context object for a single HTTP request.
 * @returns {object} Connection object
 */
function createConnectionObject(context) {
  var req = context.bindings.req;
  var xForwardedFor = req.headers ? req.headers["x-forwarded-for"] : undefined;

  return {
    encrypted: req.originalUrl && req.originalUrl.toLowerCase().startsWith("https"),
    remoteAddress: removePortFromAddress(xForwardedFor)
  };
}

/**
 * Request object wrapper
 *
 * @private
 */

var IncomingMessage = function (_EventEmitter) {
  _inherits(IncomingMessage, _EventEmitter);

  /**
   * Note: IncomingMessage assumes that all HTTP in is binded to "req" property.
   *
   * @param {Object} context Azure context object for a single HTTP request.
   */
  function IncomingMessage(context) {
    _classCallCheck(this, IncomingMessage);

    // Inherit
    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    Object.assign(_this, context.bindings.req);

    _this.url = _this.originalUrl;
    _this.headers = _this.headers || {}; // Should always have a headers object

    _this._readableState = { pipesCount: 0 }; // To make unpipe happy
    _this.resume = NOOP;
    _this.socket = { destroy: NOOP };
    _this.connection = createConnectionObject(context);

    // Add access specific objects via req.context
    _this.context = {
      log: context.log.bind(context),
      invocationId: context.invocationId
    };
    return _this;
  }

  return IncomingMessage;
}(_events2.default);

exports.default = IncomingMessage;
module.exports = exports["default"];